/*****************************************************************************
* Model: mini_sumo.qm
* File:  ./sumo.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::sumo.c} .............................................................*/
#include "qpn.h"
#include "bsp.h"

//============================================================================
// define all AO classes (state machine)...

#if ((QP_VERSION < 591) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpn version 5.9.1 or higher required
#endif

/*${AOs::Sumo} .............................................................*/
/*${AOs::Sumo::SM} .........................................................*/
QState Sumo_initial(Sumo * const me) {
    /* ${AOs::Sumo::SM::initial} */
    return Q_TRAN(&Sumo_wait);
}
/*${AOs::Sumo::SM::wait} ...................................................*/
QState Sumo_wait(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::wait} */
        case Q_ENTRY_SIG: {
            QActive_armX((QActive *)me, 0U, BSP_TICKS_PER_SEC/2U, BSP_TICKS_PER_SEC/2U);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sumo::SM::wait::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            BSP_ToggleLed();
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sumo::SM::wait::BUTTON} */
        case BUTTON_SIG: {
            QActive_armX((QActive *)me, 0U, BSP_TICKS_PER_SEC*5 - 1, BSP_TICKS_PER_SEC*5 - 1);
            status_ = Q_TRAN(&Sumo_hold);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Sumo::SM::hold} ...................................................*/
QState Sumo_hold(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::hold} */
        case Q_ENTRY_SIG: {
            BSP_LedOn();
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sumo::SM::hold} */
        case Q_EXIT_SIG: {
            BSP_LedOff();
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sumo::SM::hold::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Sumo_combat);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Sumo::SM::combat} .................................................*/
QState Sumo_combat(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::combat} */
        case Q_ENTRY_SIG: {
            QActive_armX((QActive *)me, 0, BSP_TICKS_PER_SEC*2/50, BSP_TICKS_PER_SEC*2/50);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sumo::SM::combat::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Sumo_start);
            break;
        }
        /* ${AOs::Sumo::SM::combat::EDGE} */
        case EDGE_SIG: {
            /* ${AOs::Sumo::SM::combat::EDGE::[may_go_back]} */
            if (!(me->attacking) || (me->attacking && (me->last_edge == 0))) {
                status_ = Q_TRAN(&Sumo_edge);
            }
            /* ${AOs::Sumo::SM::combat::EDGE::[else]} */
            else {
                status_ = Q_HANDLED();
            }
            break;
        }
        /* ${AOs::Sumo::SM::combat::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            BSP_ToggleLed();
            if (BSP_ReadOpSensors(me)) {
                QACTIVE_POST(&(me->super), LOST_SIG, 0);
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Sumo::SM::combat::normal} .........................................*/
QState Sumo_normal(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::combat::normal} */
        case Q_EXIT_SIG: {
            BSP_Stop();
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sumo::SM::combat::normal::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Sumo_search);
            break;
        }
        default: {
            status_ = Q_SUPER(&Sumo_combat);
            break;
        }
    }
    return status_;
}
/*${AOs::Sumo::SM::combat::normal::search} .................................*/
QState Sumo_search(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::combat::normal::search} */
        case Q_ENTRY_SIG: {
            BSP_GoForward();
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sumo::SM::combat::normal::search::LEFT} */
        case LEFT_SIG: {
            BSP_TurnSpeed(Q_PAR(me), LEFT);
            /* ${AOs::Sumo::SM::combat::normal::search::LEFT::[too_close]} */
            if (Q_PAR(me) > 51) {
                status_ = Q_TRAN(&Sumo_evade_left);
            }
            /* ${AOs::Sumo::SM::combat::normal::search::LEFT::[else]} */
            else {
                BSP_TurnSpeed(Q_PAR(me), LEFT);
                status_ = Q_HANDLED();
            }
            break;
        }
        /* ${AOs::Sumo::SM::combat::normal::search::RIGHT} */
        case RIGHT_SIG: {
            BSP_TurnSpeed(Q_PAR(me), RIGHT);
            /* ${AOs::Sumo::SM::combat::normal::search::RIGHT::[too_close]} */
            if (Q_PAR(me) > 51) {
                status_ = Q_TRAN(&Sumo_evade_right);
            }
            /* ${AOs::Sumo::SM::combat::normal::search::RIGHT::[else]} */
            else {
                BSP_TurnSpeed(Q_PAR(me), RIGHT);
                status_ = Q_HANDLED();
            }
            break;
        }
        /* ${AOs::Sumo::SM::combat::normal::search::FRONT} */
        case FRONT_SIG: {
            status_ = Q_TRAN(&Sumo_attack);
            break;
        }
        default: {
            status_ = Q_SUPER(&Sumo_normal);
            break;
        }
    }
    return status_;
}
/*${AOs::Sumo::SM::combat::normal::evade} ..................................*/
QState Sumo_evade(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::combat::normal::evade} */
        case Q_EXIT_SIG: {
            //BSP_Stop();
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sumo::SM::combat::normal::evade::LOST} */
        case LOST_SIG: {
            status_ = Q_TRAN(&Sumo_evaded);
            break;
        }
        /* ${AOs::Sumo::SM::combat::normal::evade::FRONT} */
        case FRONT_SIG: {
            status_ = Q_TRAN(&Sumo_search);
            break;
        }
        default: {
            status_ = Q_SUPER(&Sumo_normal);
            break;
        }
    }
    return status_;
}
/*${AOs::Sumo::SM::combat::normal::evade::evade_right} .....................*/
QState Sumo_evade_right(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::combat::normal::evade::evade_right} */
        case Q_ENTRY_SIG: {
            BSP_TurnRight();
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Sumo_evade);
            break;
        }
    }
    return status_;
}
/*${AOs::Sumo::SM::combat::normal::evade::evade_left} ......................*/
QState Sumo_evade_left(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::combat::normal::evade::evade_left} */
        case Q_ENTRY_SIG: {
            BSP_TurnLeft();
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Sumo_evade);
            break;
        }
    }
    return status_;
}
/*${AOs::Sumo::SM::combat::normal::attack} .................................*/
QState Sumo_attack(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::combat::normal::attack} */
        case Q_ENTRY_SIG: {
            me->attacking = 1;
            BSP_GoForward();
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sumo::SM::combat::normal::attack} */
        case Q_EXIT_SIG: {
            me->attacking = 0;
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sumo::SM::combat::normal::attack::LOST} */
        case LOST_SIG: {
            status_ = Q_TRAN(&Sumo_search);
            break;
        }
        default: {
            status_ = Q_SUPER(&Sumo_normal);
            break;
        }
    }
    return status_;
}
/*${AOs::Sumo::SM::combat::normal::evaded} .................................*/
QState Sumo_evaded(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::combat::normal::evaded} */
        case Q_ENTRY_SIG: {
            BSP_SetTimer1(500);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sumo::SM::combat::normal::evaded} */
        case Q_EXIT_SIG: {
            BSP_Stop();
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sumo::SM::combat::normal::evaded::TIMER1OVF, RIGHT, LEFT, FRONT} */
        case TIMER1OVF_SIG: /* intentionally fall through */
        case RIGHT_SIG: /* intentionally fall through */
        case LEFT_SIG: /* intentionally fall through */
        case FRONT_SIG: {
            status_ = Q_TRAN(&Sumo_search);
            break;
        }
        default: {
            status_ = Q_SUPER(&Sumo_normal);
            break;
        }
    }
    return status_;
}
/*${AOs::Sumo::SM::combat::start} ..........................................*/
QState Sumo_start(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::combat::start} */
        case Q_EXIT_SIG: {
            BSP_Stop();
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sumo::SM::combat::start::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Sumo_read);
            break;
        }
        /* ${AOs::Sumo::SM::combat::start::FRONT, TIMER1OVF} */
        case FRONT_SIG: /* intentionally fall through */
        case TIMER1OVF_SIG: {
            status_ = Q_TRAN(&Sumo_normal);
            break;
        }
        default: {
            status_ = Q_SUPER(&Sumo_combat);
            break;
        }
    }
    return status_;
}
/*${AOs::Sumo::SM::combat::start::read} ....................................*/
QState Sumo_read(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::combat::start::read} */
        case Q_ENTRY_SIG: {
            BSP_ReadMode(me);
            if (BSP_ReadOpSensors(me)) {
                QACTIVE_POST(&(me->super), BACK_SIG, 0);
            }
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sumo::SM::combat::start::read::RIGHT} */
        case RIGHT_SIG: {
            status_ = Q_TRAN(&Sumo_is_right);
            break;
        }
        /* ${AOs::Sumo::SM::combat::start::read::LEFT} */
        case LEFT_SIG: {
            status_ = Q_TRAN(&Sumo_is_left);
            break;
        }
        /* ${AOs::Sumo::SM::combat::start::read::BACK} */
        case BACK_SIG: {
            status_ = Q_TRAN(&Sumo_is_back);
            break;
        }
        default: {
            status_ = Q_SUPER(&Sumo_start);
            break;
        }
    }
    return status_;
}
/*${AOs::Sumo::SM::combat::start::is_back} .................................*/
QState Sumo_is_back(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::combat::start::is_back} */
        case Q_ENTRY_SIG: {
            /*switch (me->combat_mode) {
                case 0x00:
                    break;
                case 0x03:
                    break;
                default:
                    break;
            }*/
            BSP_TurnLeft();
            BSP_SetTimer1(1000);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Sumo_start);
            break;
        }
    }
    return status_;
}
/*${AOs::Sumo::SM::combat::start::is_left} .................................*/
QState Sumo_is_left(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::combat::start::is_left} */
        case Q_ENTRY_SIG: {
            switch (me->combat_mode) {
                case 0x00:
                    BSP_TurnLeft();
                    BSP_SetTimer1(660);
                    break;
                case 0x03:
                    BSP_TurnSpeed(40, LEFT);
                    //BSP_SetTimer1(660);
                    break;
                default:
                    BSP_TurnLeft();
                    BSP_SetTimer1(660);
                    break;
            }
            //BSP_TurnLeft();
            //BSP_SetTimer1(660);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Sumo_start);
            break;
        }
    }
    return status_;
}
/*${AOs::Sumo::SM::combat::start::is_right} ................................*/
QState Sumo_is_right(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::combat::start::is_right} */
        case Q_ENTRY_SIG: {
            switch (me->combat_mode) {
                case 0x00:
                    BSP_TurnRight();
                    BSP_SetTimer1(660);
                    break;
                case 0x03:
                    BSP_TurnSpeed(40, RIGHT);
                    //BSP_SetTimer1(660);
                    break;
                default:
                    BSP_TurnRight();
                    BSP_SetTimer1(660);
                    break;
            }
            //BSP_TurnRight();
            //BSP_SetTimer1(660);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Sumo_start);
            break;
        }
    }
    return status_;
}
/*${AOs::Sumo::SM::combat::turn} ...........................................*/
QState Sumo_turn(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::combat::turn} */
        case Q_ENTRY_SIG: {
            if (me->last_edge == 0x01) {
                BSP_TurnRight();
            }
            else {
                BSP_TurnLeft();
            }
            BSP_SetTimer1(500);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sumo::SM::combat::turn} */
        case Q_EXIT_SIG: {
            BSP_Stop();
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sumo::SM::combat::turn::TIMER1OVF, FRONT, RIGHT, LEFT} */
        case TIMER1OVF_SIG: /* intentionally fall through */
        case FRONT_SIG: /* intentionally fall through */
        case RIGHT_SIG: /* intentionally fall through */
        case LEFT_SIG: {
            status_ = Q_TRAN(&Sumo_normal);
            break;
        }
        default: {
            status_ = Q_SUPER(&Sumo_combat);
            break;
        }
    }
    return status_;
}
/*${AOs::Sumo::SM::edge} ...................................................*/
QState Sumo_edge(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::edge::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Sumo_back);
            break;
        }
        /* ${AOs::Sumo::SM::edge::INSIDE} */
        case INSIDE_SIG: {
            status_ = Q_TRAN(&Sumo_turn);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Sumo::SM::edge::back} .............................................*/
QState Sumo_back(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::edge::back} */
        case Q_ENTRY_SIG: {
            BSP_GoBack();
            BSP_delay_ms(250);
            QActive_armX((QActive *)me, 0U, BSP_TICKS_PER_SEC/2, BSP_TICKS_PER_SEC/2);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Sumo::SM::edge::back::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Sumo_strafe);
            break;
        }
        default: {
            status_ = Q_SUPER(&Sumo_edge);
            break;
        }
    }
    return status_;
}
/*${AOs::Sumo::SM::edge::strafe} ...........................................*/
QState Sumo_strafe(Sumo * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Sumo::SM::edge::strafe} */
        case Q_ENTRY_SIG: {
            BSP_GoBack();
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Sumo_edge);
            break;
        }
    }
    return status_;
}

//...
